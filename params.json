{"name":"Daemon","tagline":"A daemon package for use with Go (golang) services with no dependencies","body":"Go Daemon\r\n=========\r\n\r\nA daemon package for use with Go (golang) services with no dependencies\r\n\r\n### Examples\r\n\r\nSimplest example (just install self as daemon):\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"log\"\r\n\r\n\t\"github.com/takama/daemon\"\r\n)\r\n\r\nfunc main() {\r\n\tservice, err := daemon.New(\"name\", \"description\")\r\n\tif err != nil {\r\n\t\tlog.Fatal(\"Error: \", err)\r\n\t}\r\n\tstatus, err := service.Install()\r\n\tif err != nil {\r\n\t\tlog.Fatal(status, \"\\nError: \", err)\r\n\t}\r\n\tfmt.Println(status)\r\n}\r\n```\r\n\r\nReal example:\r\n```go\r\n// Example of a daemon with echo service\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"log\"\r\n\t\"net\"\r\n\t\"os\"\r\n\t\"os/signal\"\r\n\t\"syscall\"\r\n\r\n\t\"github.com/takama/daemon\"\r\n)\r\n\r\nconst (\r\n\r\n\t// name of the service, match with executable file name\r\n\tname        = \"myservice\"\r\n\tdescription = \"My Echo Service\"\r\n\r\n\t// port which daemon should be listen\r\n\tport = \":9977\"\r\n)\r\n\r\nvar stdlog, errlog *log.Logger\r\n\r\n// Service has embedded daemon\r\ntype Service struct {\r\n\tdaemon.Daemon\r\n}\r\n\r\n// Manage by daemon commands or run the daemon\r\nfunc (service *Service) Manage() (string, error) {\r\n\r\n\tusage := \"Usage: myservice install | remove | start | stop | status\"\r\n\r\n\t// if received any kind of command, do it\r\n\tif len(os.Args) > 1 {\r\n\t\tcommand := os.Args[1]\r\n\t\tswitch command {\r\n\t\tcase \"install\":\r\n\t\t\treturn service.Install()\r\n\t\tcase \"remove\":\r\n\t\t\treturn service.Remove()\r\n\t\tcase \"start\":\r\n\t\t\treturn service.Start()\r\n\t\tcase \"stop\":\r\n\t\t\treturn service.Stop()\r\n\t\tcase \"status\":\r\n\t\t\treturn service.Status()\r\n\t\tdefault:\r\n\t\t\treturn usage, nil\r\n\t\t}\r\n\t}\r\n\r\n\t// Do something, call your goroutines, etc\r\n\r\n\t// Set up channel on which to send signal notifications.\r\n\t// We must use a buffered channel or risk missing the signal\r\n\t// if we're not ready to receive when the signal is sent.\r\n\tinterrupt := make(chan os.Signal, 1)\r\n\tsignal.Notify(interrupt, os.Interrupt, os.Kill, syscall.SIGTERM)\r\n\r\n\t// Set up listener for defined host and port\r\n\tlistener, err := net.Listen(\"tcp\", port)\r\n\tif err != nil {\r\n\t\treturn \"Possibly was a problem with the port binding\", err\r\n\t}\r\n\r\n\t// set up channel on which to send accepted connections\r\n\tlisten := make(chan net.Conn, 100)\r\n\tgo acceptConnection(listener, listen)\r\n\r\n\t// loop work cycle with accept connections or interrupt\r\n\t// by system signal\r\n\tfor {\r\n\t\tselect {\r\n\t\tcase conn := <-listen:\r\n\t\t\tgo handleClient(conn)\r\n\t\tcase killSignal := <-interrupt:\r\n\t\t\tstdlog.Println(\"Got signal:\", killSignal)\r\n\t\t\tstdlog.Println(\"Stoping listening on \", listener.Addr())\r\n\t\t\tlistener.Close()\r\n\t\t\tif killSignal == os.Interrupt {\r\n\t\t\t\treturn \"Daemon was interruped by system signal\", nil\r\n\t\t\t}\r\n\t\t\treturn \"Daemon was killed\", nil\r\n\t\t}\r\n\t}\r\n\r\n\t// never happen, but need to complete code\r\n\treturn usage, nil\r\n}\r\n\r\n// Accept a client connection and collect it in a channel\r\nfunc acceptConnection(listener net.Listener, listen chan<- net.Conn) {\r\n\tfor {\r\n\t\tconn, err := listener.Accept()\r\n\t\tif err != nil {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tlisten <- conn\r\n\t}\r\n}\r\n\r\nfunc handleClient(client net.Conn) {\r\n\tfor {\r\n\t\tbuf := make([]byte, 4096)\r\n\t\tnumbytes, err := client.Read(buf)\r\n\t\tif numbytes == 0 || err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tclient.Write(buf)\r\n\t}\r\n}\r\n\r\nfunc init() {\r\n\tstdlog = log.New(os.Stdout, \"\", log.Ldate|log.Ltime)\r\n\terrlog = log.New(os.Stderr, \"\", log.Ldate|log.Ltime)\r\n}\r\n\r\nfunc main() {\r\n\tsrv, err := daemon.New(name, description)\r\n\tif err != nil {\r\n\t\terrlog.Println(\"Error: \", err)\r\n\t\tos.Exit(1)\r\n\t}\r\n\tservice := &Service{srv}\r\n\tstatus, err := service.Manage()\r\n\tif err != nil {\r\n\t\terrlog.Println(status, \"\\nError: \", err)\r\n\t\tos.Exit(1)\r\n\t}\r\n\tfmt.Println(status)\r\n}\r\n```\r\n\r\n## Author\r\n\r\n[Igor Dolzhikov](https://github.com/takama)\r\n\r\n## Contributors\r\n\r\nAll the contributors are welcome. If you would like to be the contributor please accept some rules.\r\n- The pull requests will be accepted only in \"develop\" branch\r\n- All modifications or additions should be tested\r\n- Sorry, I'll not accept code with any dependency, only standard library\r\n\r\nThank you for your understanding!\r\n\r\n## License\r\n\r\n[MIT Public License](https://github.com/takama/daemon/blob/master/LICENSE)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}